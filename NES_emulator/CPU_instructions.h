#pragma once

enum CPUinstructions {
	ADC_IM = 0x69, //add with carry
	ADC_ZP = 0x65,
	ADC_ZPX = 0x75,
	ADC_ABS = 0x6D,
	ADC_ABSX = 0x7D,
	ADC_ABSY = 0x79,
	ADC_INDX = 0x61,
	ADC_INDY = 0x71,
	AND_IM = 0x29, //AND operation
	AND_ZP = 0x25,
	AND_ZPX = 0x35,
	AND_ABS = 0x2D,
	AND_ABSX = 0x3D,
	AND_ABSY = 0x39,
	AND_INDX = 0x21,
	AND_INDY = 0x31,
	ASL_ACC = 0x0A, //shift bits left
	ASL_ZP = 0x06,
	ASL_ZPX = 0x16,
	ALS_ABS = 0x0E,
	ALS_ABSX = 0x1E,
	BCC = 0x90, //branch if carry clear
	BCS = 0xB0, //branch if carry set
	BEQ = 0xF0, //branch if equal
	BIT_ZP = 0x24, //bit test
	BIT_ABS = 0x2C,
	BMI = 0x30, //branch if minus
	BNE = 0xD0, //branch if not equal
	BPL = 0x10, //branch if positive
	BRK = 0x00, //force interrupt
	BVC = 0x50, //branch if overflow clear
	BVS = 0x70, //branch if overflow set
	CLC = 0x18, //clear carry flag
	CLD = 0xD8, //clear decimal mode
	CLI = 0x58, //clear interrupt disable
	CLV = 0xB8, //clear overflow flag
	CMP_IM = 0xC9, //Compare
	CMP_ZP = 0xC5,
	CMP_ZPX = 0xD5,
	CMP_ABS = 0xCD,
	CMP_ABSX = 0xDD,
	CMP_ABSY = 0xD9,
	CMP_INDX = 0xC1,
	CMP_INDY = 0xD1,
	CPX_IM = 0xE0, //compare X
	CPX_ZP = 0xE0,
	CPX_ABS = 0xEC,
	CPY_IM = 0xC0, //compare Y
	CPY_ZP = 0xC4,
	CPY_ABS = 0xCC,
	DEC_ZP = 0xC6, //decrement memory
	DEC_ZPX = 0xD6,
	DEC_ABS = 0xCE,
	DEC_ABSX = 0xDE,
	DEX = 0xCA, //decrement X register
	DEY = 0x88, //decrement Y register
	EOR_IM = 0x49, //exclusive OR
	EOR_ZP = 0x45,
	EOR_ZPX = 0x55,
	EOR_ABS = 0x4D,
	EOR_ABSX = 0x5D,
	EOR_ABSY = 0x59,
	EOR_INDX = 0x41,
	EOR_INDY = 0x51,
	INC_ZP = 0xE6, //increment memory
	INC_ZPX = 0xF6,
	INC_ABS = 0xEE,
	INC_ABSX = 0xFE,
	INX = 0xE8, //increment X register
	INY = 0xC8, //increment Y register
	JMP_ABS = 0x4C, //jump
	JMP_IND = 0x6C,
	JSR = 0x20, //jump to subroutine
	LDA_IM = 0xA9, //Load accumulator
	LDA_ZP = 0xA5,
	LDA_ZPX = 0xB5,
	LDA_ABS = 0xAD,
	LDA_ABSX = 0xBD,
	LDA_ABSY = 0xB9,
	LDA_INDX = 0xA1,
	LDA_INDY = 0xB1,
	LDX_IM = 0xA2, //Load X register
	LDX_ZP = 0xA6,
	LDX_ZPY = 0xB6,
	LDX_ABS = 0xAE,
	LDX_ABSY = 0xBE,
	LDY_IM = 0xA0, //Load A register
	LDY_ZP = 0xA4,
	LDY_ZPX = 0xB4,
	LDY_ABS = 0xAC,
	LDY_ABSX = 0xBC,
	LSR_ACC = 0x4A, //logical shift right
	LSR_ZP = 0x46,
	LSR_ZPX = 0x56,
	LSR_ABS = 0x4E,
	LSR_ABSX = 0x5E,
	NOP = 0xEA, //no operation
	ORA_IM = 0x09, //logical inclusive OR
	ORA_ZP = 0x05,
	ORA_ZPX = 0x15,
	ORA_ABS = 0x0D,
	ORA_ABSX = 0x1D,
	ORA_ABSY = 0x19,
	ORA_INDX = 0x01,
	ORA_INDY = 0x11,
	PHA = 0x48, //push accumulator on to the stack
	PHP = 0x08, //push cpu status flags onto stack
	PLA = 0x68, //pull accumulator from stack
	PLP = 0x29, //pull cpu status flags from stack
	ROL_ACC = 0x2A, //rotate left
	ROL_ZP = 0x26,
	ROL_ZPX = 0x36,
	ROL_ABS = 0x2E,
	ROL_ABSX = 0x3E,
	ROR_ACC = 0x6A, //rotate right
	ROR_ZP = 0x66,
	ROR_ZPX = 0x76,
	ROR_ABS = 0x6E,
	ROR_ABSX = 0x7E,
	RTI = 0x40, //return from interrupt
	RTS = 0x60, //return from subroutine
	SBC_IM = 0xE9, //substract with carry
	SBC_ZP = 0xE5,
	SBC_ZPX = 0xF5,
	SBC_ABS = 0xED,
	SBC_ABSX = 0xFD,
	SBC_ABSY = 0xF9,
	SBC_INDX = 0xE1,
	SBC_INDY = 0xF1,
	SEC = 0x38, //set carry flag
	SED = 0xF8, //set decimal flag
	SEI = 0x78, //set interrupt disable
	STA_ZP = 0x85, //store accumulator
	STA_ZPX = 0x95,
	STA_ABS = 0x8D,
	STA_ABSX = 0x9D,
	STA_ABSY = 0x99,
	STA_INDX = 0x81,
	STA_INDY = 0x91,
	STX_ZP = 0x86, //store X register
	STX_ZPY = 0x96,
	STX_ABS = 0x8E,
	STY_ZP = 0x84, //store Y register
	STY_ZPX = 0x94,
	STY_ABS = 0x8C,
	TAX = 0xAA, //transfer accumulator to X
	TAY = 0xA8, //transfer accumulator to Y
	TSX = 0xBA, //transfer stack pointer to X
	TXA = 0x8A, //transfer X to accumulator
	TXS = 0x9A, //transfer X to stack pointer
	TYA = 0x98 //transfer Y to accumulator
};